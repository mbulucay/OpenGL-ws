Shaders and Rendering Pipeline

Shader:
    A program just runs on the gpu what needs to do with vertex buffer


diyelim ki bir ucgen cizeceksin opengl bunu cizmek icin gerekli adimlari biliyor ama senden bekledigi
    senden bu buffer i kullanarak cizmeni istiyorum
    senden bu shader i kullanarak cizmeni istiyorum
    draw me a triangle

STATE MACHINE

Rendering Pipeline:
    Bir resmin rander edilip kullaniciya sonulmasi icin gectigi asamalar butunu
    Shader types:
        1. Vertex Shader:
        2. Fragment Shader:
        3. Geometry Shader:
        4. Tessellation Shader:
        5. Compute Shader:
        6. Ray Tracing Shader:
        7. All Shaders:
    
    Shader stages: (daha az veya daha cok olabilir sasirma hemen sonra)
        1. Vertex specification:
            Program icerinden render olmasini istegimiz yerlerin veya sekillerinin
            datalarinin tutuldugu bizim tanimladigimiz uzayda noktlar kumesi

                .       Herbiri birer vertex
               . .      Uygulaminin kendisinde tanimlariz

              _____     line yine data yine specification

            VAO => Vertex Array Object
                Vertexin ozellilerinn oldugu yer renk, texture, normals gibi ...
            VBO => Vertex Buffer Objects
                Datanin kendisini temsil eder

            In short words, VBO is an array of raw data, when VAO is an array of ATTRIBUTES - an instruction for shader program how to use the data.
            A VBO is a buffer of memory which the gpu can access. That all it is.
            A VAO is an object that stores vertex bindings. 

            Attribure Pointers define where and how shaders can access vertex data

            Binding photoshop taki layer sistemi gibi hangi layer a datalari kullanarak cizmek istiyorsan o layer a bind olmalisin

            cizimde 
                activate shader program
                bind vao of objects you want to draw
                call glDrawArrays which initiates the rest of the pipeline 

        2. Vertex Shader (programmable)
            
            Bir noktayi bireysel olrak isleme sokuldugu adim

            layout (location = 0) in vec3 pos;
            void main
                gl_Position = vec4(pos, 1.0)

            The Vertex Shader is the programmable Shader stage in the rendering pipeline that handles the processing of individual vertices. Vertex shaders are fed Vertex Attribute data, as specified from a vertex array object by a drawing command. A vertex shader receives a single vertex from the vertex stream and generates a single vertex to the output vertex stream. There must be a 1:1 mapping from input vertices to output vertices.

            The process of vertex specification is where the application sets up an ordered list of vertices to send to the pipeline. These vertices define the boundaries of a primitive.
            Primitives are basic drawing shapes, like triangles, lines, and points. Exactly how the list of vertices is interpreted as primitives is handled via a later stage.
        
        3. Tessellation Control Shader (programmable)

            Allows you to divide up data in to smaller primitives
                Karisik geometrileri 3gen lere boluyormus anladigim kadariyla
            Relatively new shader type appeared in oGL 4.0
            Can be used to add higher levels of detail dynamically

            https://www.khronos.org/opengl/wiki/Tessellation
            sadece 3 genlere degil mesela bi line var onu da daha kucuk parcalara bolerek isliyor
            okyanus, su gibi surekli dinamik degiskenlik gosteren yerlerde kullaniliyor

        4. Tessellation Evaluation Shader (programmable)
        
            Primitives can be tessellated using two shader stages and a fixed-function tessellator between them. 
            The Tessellation Control Shader (TCS) stage comes first, and it determines the amount of tessellation to apply to a primitive, 
            as well as ensuring connectivity between adjacent tessellated primitives. The Tessellation Evaluation Shader (TES) stage comes last, and it applies the interpolation or 
            other operations used to compute user-defined data values for primitives generated by the fixed-function tessellation process.

            primitive: birden fazla vertexin birlesmesiyle orta cikan sekil ucgen gibi

            cikti olarak da verilen vertexleri mesela hareket ettireceksin verdigin vertexleri ona gore isleme sokup
            sana yeni lokasyonlarinin oldugu primitive yani seklin vertexlernin yeni konumunu verir 


        5. Geometry Shader (programmable)

            vertex shader bir noktayi isliyor ama geometry shader noktalar grubu, bir grup noktayi handle ediyor 

            primitiveleri alir onlarin vertexlerini cikarir ve verilen primitive i cikarmaya calisir 

            Geometry shaders are user-defined programs that process each incoming primitive, returning zero or more output primitives.
        
        6. Vertex Post-processing Shader
            
            Transform-FeedBack
                Shader sonucu olusan noktalar sonra kullanilmak icin kayit ediliyor
                surekli kullanilacak vertexler bi yere kaydedilip tekrar tekrar kullanililabilir

            Clipping
                Kullanicinin gorunumune girmeyen seklerin hesaplanmasindan kacilmasi bosu bosuna cycle yememesi gereksiz yere
                Primitives that wont be visible are removed

                Positiions converted from "cliped space" to "window space" 

        7. Primitive Assembly

            vetexler primitive serilerine donusturuyorlar
            mesela ucgen render edityorsun 6 vertexin var 6 / 3 den 2 tane ucgen primitive ine donusturuluyor

            face culling: 
                yine gordumuz seyleri ciziyoruz sadece 
                ucgenin veya herhangi bir 2 boyutlu yuzeyin sadece bize gorunen tarafini ciziyoruz 
                yani saaat yonunde gidersen yuzxeyin normalinin oldugu kismi render ediyor 3 genin arka tarafini render etmeye gerek duymuyor 
                gorulmeyen primitevelerin kaldirilmasi


        8. Rasterization
            primitivelerin kapladiklari pikseller seciliyor 

            fragment:
                fragments are pieces of data for each pixel, obtained form the rasterization process (rengi  falan)  

        9. Fragment Shader (programmable) (onemli shader)
            
            Handles data for each fragment. Her pixel icin hesaplama 
            en onemli ciktiis fragmenting bulundugu pixeli renklendirip istedigimiz seyi cizebiliriz

            out vec4 colour;

            main()
                colour = vec4(1.0, 1.0, 0.0, 1.0)


        10. Fragment Post-processing Shader
        11. Per-Sample Operations
            
            The following operations are able to be performed before the fragment shader, under certain circumstances (and in the following order):
                The pixel ownership test
                The scissor test
                The stencil test
                The depth test
                Occlusion query updating
            There are two circumstances when these operations can be performed before the fragment shader. It can happen as an implicit optimization, if OpenGL detects that the fragment shader's execution will not interfere with these tests. Or it can happen if the fragment shader explicitly requests it.

            If it happens by explicit request of the fragment shader, then all of these operations will happen first


            hangi fragmentin ekrana cizilecegi ile ilgili bir dizi test
            buna karar verirken derinlik one cikiyor bu yuzden bu islem icerisindeki en onmli test depth test

            Colour blending:
                cakisan fragmentler us uste blend ediliyormus genellikle transparan objeler icin kullaniliyor cam gibi

            fragment data mevcut fragment buffer uzerine yaziliyor ve frame update ediliyor


        Genel anlamda 2 bufferin var birisi edit icin yani next frame icin biride kullaniciya gosterdigin hazir olan buffer
        bunlari sirasiyla swap ederek hareketli gonruntu elde edebilirsin

        https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview


        Shaders programs are a group of shaders vertex tessellation geomerty fragment associated with one another

    Creating Shader Program:
        1-Create empty program
        2-Create empty shaders
        3-Attach shader source code to shaders
        4-Compile shaders
        5-Attach Shader progmram
        6-Link program (create executables from shaders and link them together)
        7-Validate Program (useful for debugging)

        shader olustuduktan sonra Id aliyorsun sonra glUseProgram(shaderID)

GLSL:
    GLSL,(OpenGL Tarayıcı Dili,GLsLang diye de bilinir) C tabanlı yüksek seviye bir programlama dilidir.
    OpenGL ARB tarafından,geliştiricilerin grafik işhattına assembly veya donanım-bağımlı bir dil bilmeden direkt erişim sağlaması için yaratılmıştır.

    (!Kullandigimiz!) based on c programing language

HLSL:
    Yüksek-Seviye Gölgelendirme Dili, HLSL, uzun adıyla High-Level Shader Language ya da High-Level Shading Language [1]
    (Yüksek-Seviye Gölgelendirme Dili) Microsoft tarafından gölgelendirme derleme dilini genişletmek için 
    Direct3D 9 API'ı özelinde geliştirilmiş tescilli bir gölgelendirme dilidir. 
    Direct3D 10 ve üzeri için gerekliliği bulunan standart haline gelmiş bir gölgelendirme dilidir


VRAM:
    Video Ram, Gpu Ram
